---
title: "Let's Practice Spatial data and cartography with R"
author: "Kim A. Etienne C. Timothée G."
date: "**SatRday Paris** February 2019"
output:
  unilur::tutorial_html_solution:
    toc: true
    toc_float: false
    toc_depth: 1
    suffix: ""
    theme: journal
    highlight: kate
    number_sections: no
    number_subsections: no
---

```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}
library(stringr)
library(knitr)
## Global options
options(max.print="90")
opts_chunk$set(echo=TRUE,
	             cache=FALSE, #TRUE
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=90)
options(width = 90)

# no margins
knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  }
})

# title margins
knit_hooks$set(sm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,1.2,0))
  }
})

# boxes custom
#devtools::install_github("koncina/unilur")
knitr::opts_template$set(alert = list(box.title = "Watch out!",
                                      box.body = list(fill = "#ffe0d9", colour = "black"),
                                      box.header = list(fill = "#FFAD99", colour = "black"),
                                      box.collapse = NULL,
                                      box.icon = "fa-exclamation-triangle"))
knitr::opts_template$set(solution = list(box.title = "Solution",
                                         box.body = list(fill = "#e6f6e7", colour = "black"),
                                         box.header = list(fill = "#ace1af", colour = "black"),
                                         box.icon = "fa-check-square",
                                         box.collapse = TRUE))
knitr::opts_template$set(information = list(box.title = "Information",
                                            box.body = list(fill = "#bbe8f4", colour = "black"),
                                            box.header = list(fill = "#64c9e6", colour = "black"),
                                            box.icon = "fa-info-circle",
                                            box.collapse = NULL))
knitr::opts_template$set(clues = list(box.title = "Clues",
                                      box.body = list(fill = "#fff9dc", colour = "black"),
                                      box.header = list(fill = "#ffec8b", colour = "black"),
                                      box.icon = "fa-search",
                                      box.collapse = TRUE))
```

The main data used in this tutorial and in the lecture are about the **geolocalisation of french restaurants** in Paris. Data is extracted from an official register called [**SIRENE**](https://www.data.gouv.fr/fr/datasets/base-sirene-des-entreprises-et-de-leurs-etablissements-siren-siret/) (Computer system for the business and establishment register) managed by the French National Institute of Statistics and Economic Studies ([Insee](https://www.insee.fr/en/accueil)) and [geolocated](http://data.cquest.org/geo_sirene/last/) by [Etalab](https://www.etalab.gouv.fr/) (French task force for Open Data). This register records the civil status of all companies and their establishments (including restaurants).
SIRENE has the advantages of being rigorous and exhaustive on the French territory.



# Exercise 1 : Manipulate sf objects and associated data.frames

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}
Import the iris[^1] map layer 'iris_75.shp' of Paris.
```


[^1]: In French, IRIS is an acronym of ‘aggregated units for statistical information’. Their target sizes are 2000 residents per basic unit.

```{block, opts.label = "clues"}
Use `sf::st_read()`.
```

```{r, solution = TRUE}
library(sf)
iris_75 <- st_read("data/iris_75.shp")
```



```{block, box.title = "2", box.body = list(fill = "white"), box.icon = "fa-star"}
Display the basemap of Paris with `plot(iris_75)`.
What do you notice ?
```

```{r, nm=TRUE, solution = TRUE}
plot(iris_75)
```

```{block, solution = TRUE}
We notice that R performs 4 graphs: one graph per variable in the sf object.
```

```{block, box.title = "3", box.body = list(fill = "white"), box.icon = "fa-star"}
What is the functionality of the `sf::st_geometry()` function? What solution do you propose then?
```

```{block, solution = TRUE}
`sf::st_geometry()` makes it possible to isolate the information contained in the 'geometry' column of the sf object. Using it, we put aside other variables (here *CODE_IRIS*, *P14_POP*, *AREA* and *CODE_COM*).
```


```{r, nm=TRUE, solution = TRUE}
plot(st_geometry(iris_75))
```



```{block, box.title = "4", box.body = list(fill = "white"), box.icon = "fa-star"}
Import the restaurant layer 'sir.shp' and display a map of Paris with its restaurants. 
```

```{block, solution = TRUE}
Use `st_read()` and `sf::st_geometry()`.
```


```{r, sm=TRUE, solution = TRUE}
sir_75 <- st_read("data/sir_75.shp")
plot(st_geometry(iris_75), bg = "cornsilk", col = "lightblue", 
     border = "white", lwd = .5)
plot(st_geometry(sir_75), col = "red", pch = 20, cex = .2, add=TRUE)
title("Restaurants in Paris")
```



```{block, box.title = "5", box.body = list(fill = "white"), box.icon = "fa-star"}
Count the number of restaurant by iris. 
```

```{block, opts.label = "clues"}
Use `sf::st_intersects()` and `sapply()`.
```


```{block, solution = TRUE}
wwww

```


```{r, nm=TRUE, solution = TRUE}
inter <- st_intersects(x = iris_75, y = sir_75)
iris_75$RESTAU <- sapply(inter, length)
head(iris_75)
```



```{block, box.title = "6", box.body = list(fill = "white"), box.icon = "fa-star"}
Using the layer called ‘iris_75’, create a new aggregated map layer called ‘com_75’ which corresponds to the Paris Arrondissements. Also keep in this new layer the information on the population, area and number of restaurant in each municipality.
```

```{block, opts.label = "information"}
The map layer called ‘iris_75’ contains the 5 digit codes of arrondissemnt in its variable *CODE_COM*.
```

```{block, opts.label = "clues"}
Use the classic functions of `dplyr` package: `select`, `group_by` et `summarize`.
These functions also work with `sf` objects.
```


```{r, nm=TRUE, eval=FALSE, solution = TRUE}
library(dplyr)
com_75 <- iris_75 %>%
  group_by(CODE_COM) %>%
  summarize(P14_POP = sum(P14_POP), 
            AREA = sum(AREA), 
            RESTAU = sum(RESTAU)) 

```

```{r, nm=TRUE, echo=FALSE}
library(dplyr)
com_75 <- iris_75 %>%
  group_by(CODE_COM) %>%
  summarize(P14_POP = sum(P14_POP), 
            AREA = sum(AREA), 
            RESTAU = sum(RESTAU)) 

plot(st_geometry(com_75))
```









```{r, solution=TRUE}
library(sf)
library(cartography)
library(dplyr)
# Import data
fra <- st_read("data/fra.shp", quiet = TRUE)
# Create the variable
com_75$nb_rest_10000inhab <- 10000 * com_75$RESTAU / com_75$P14_POP
# Define breaks
bks <- getBreaks(v = com_75$nb_rest_10000inhab, method = "quantile", nclass = 4)
# Define color palette
cols <- carto.pal("wine.pal", length(bks)-1)

# Define plot margins
par(mar = c(0.2, 0.2, 1.4, 0.2), bg = "azure")
# Find EPCI bounding box
bb <- st_bbox(com_75)
# Plot France using EPCI boundingbox
plot(st_geometry(fra), col="ivory", border = "ivory3",
     xlim = bb[c(1, 3)], ylim = bb[c(2, 4)])
# Plot the choropleth layer
choroLayer(com_75, var = "nb_rest_10000inhab",
           breaks = bks, col = cols, lwd = 0.5,
           legend.pos = "topleft",add = TRUE, border = "white",
           legend.title.txt = "Number of restaurants\nfor 10,000 inhabitants")
# Plot proportionnal symbols
propSymbolsLayer(com_75, var="RESTAU", col="#ffffff80",border = "grey20",
                 legend.pos="left", inches=0.3, add = TRUE, lwd = 1,
                 legend.title.txt = "Number of restaurants")
# Add a layout layer
layoutLayer(title = "Restaurants", sources = "Insee, 2018",
            author = "Kim & Tim, 2018", tabtitle = TRUE, 
            theme = "green.pal", col = "darkred",
            coltitle = "white", 
            frame = TRUE, scale = 2)
# Add a north (south) arrow
north(pos = "topright", south = TRUE)

```




# Exercise 2 : Static maps

We would like here to design EPCI maps that combine the number of restaurants and the number of restaurants per 10,000 inhabitants. The EPCI correspond to the level of french intercommunalites.

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}
Data preparation:

* Load ‘fra.shp’ in R: the map layer of the borders of the French metropolitan territory.
* Load the layer called ‘epci_31.rds’ (which contains the population and the number of restaurants in each EPCI) and create a variable called *nb_rest_10000inhab* which corresponds to the number of restaurants per 10,000 inhabitants in each territory.
* Create a vector of quantiles breaks of the *nb_rest_10000inhab* variable.
* Create the vector colors which corresponds to a the number of classes defined earlier.
* Finally, add  a variable called *typo* to 'epci_31' which indicates the class of the territory according to the discretization contained in *bks* for the  *nb_rest_10000inhab* variable (this is needed for ggplot2 maps).
```

```{block, opts.label = "information"}
For the creation of ‘bks’ et ‘cols’, use the `getBreaks` et `carto.pal` functions of the  `cartography` package.
For the creation of the *typo* variable, you can use the `cut` function and apply the parameters `digit.lab = 2` and `include.lowest = TRUE`.
```

```{r, solution=TRUE}
library(sf)
library(cartography)
library(dplyr)
# Import data
fra <- st_read("data/fra.shp", quiet = TRUE)
epci_31 <- readRDS("data/epci_31.rds")
# Create the variable
epci_31$nb_rest_10000inhab <- 10000 * epci_31$nb_of_rest / epci_31$P14_POP
# Define breaks
bks <- getBreaks(v = epci_31$nb_rest_10000inhab, method = "quantile", nclass = 4)
# Define color palette
cols <- carto.pal("orange.pal", length(bks)-1)
# Create a "typo"" variable
epci_31 <- epci_31 %>%
  mutate(typo = cut(nb_rest_10000inhab,breaks = bks, dig.lab = 2,
                    include.lowest = TRUE))
```


```{block, box.title = "2", box.body = list(fill = "white"), box.icon = "fa-star"}
With the help of `cartography` package, make the following map which contains in a choropleth layer the variable *nb_rest_10000inhab* and in a proportional circle layer the variable *nb_of_rest*. The you can try to do the same map using the `ggplot2` and `tmaps`  packages.
```


With cartography:

```{r, eval=FALSE, solution=TRUE}
# Define plot margins
par(mar = c(0.2, 0.2, 1.4, 0.2), bg = "azure")
# Find EPCI bounding box
bb <- st_bbox(epci_31)
# Plot France using EPCI boundingbox
plot(st_geometry(fra), col="ivory", border = "ivory3",
     xlim = bb[c(1, 3)], ylim = bb[c(2, 4)])
# Plot the choropleth layer
choroLayer(epci_31, var = "nb_rest_10000inhab",
           breaks = bks, col = cols, border = "grey80", lwd = 0.5,
           legend.pos = "topleft",add = TRUE,
           legend.title.txt = "Number of restaurants\nfor 10,000 inhabitants")
# Plot proportionnal symbols
propSymbolsLayer(epci_31, var="nb_of_rest", col="#440170",border=NA,
                 legend.pos="left", inches=0.4, add = TRUE,
                 legend.title.txt = "Number of restaurants")
# Add a layout layer
layoutLayer(title = "Restaurants", sources = "Insee, 2018",
            author = "Kim & Tim, 2018",
            theme = "green.pal", col = "darkred",
            coltitle = "white", postitle = "center",
            frame = TRUE, scale = 10)
# Add a north (south) arrow
north(pos = "topright", south = TRUE)
```

With ggplot2:

```{r, eval=FALSE, solution=TRUE}
library(ggplot2)

map_ggplot <- ggplot() +
  geom_sf(data = fra, colour = "ivory3",
          fill = "ivory") +
  geom_sf(data = epci_31, aes(fill = typo), colour = "grey80") +
  scale_fill_manual(name = "Number of restaurants\nfor 10,000 inhabitants",
                    values = cols, na.value = "#303030")+
   geom_sf(data = epci_31 %>%  st_centroid(),
           aes(size= nb_of_rest), color = "#440154CC", show.legend = 'point')+
  scale_size(name = "Number of restaurants",
             breaks = c(1, 500, 3200),
             range = c(0,18))+
  coord_sf(crs = 2154, datum = NA,
           xlim = st_bbox(epci_31)[c(1,3)],
           ylim = st_bbox(epci_31)[c(2,4)]
  ) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "azure",color=NA)) +
  labs(
      title = "Restaurants",
      caption = "Insee, 2018\nKim & Tim, 2018"
  )

plot(map_ggplot)
```

**With tmap:**

**TODO Timothée**


#### {.tabset}

##### cartography
```{r, nm=TRUE, echo=FALSE}
# Define plot margins
par(mar = c(0.2, 0.2, 1.4, 0.2), bg = "azure")
# Find EPCI bounding box
bb <- st_bbox(epci_31)
# Plot France using EPCI boundingbox
plot(st_geometry(fra), col="ivory", border = "ivory3",
     xlim = bb[c(1, 3)], ylim = bb[c(2, 4)])
# Plot the choropleth layer
choroLayer(epci_31, var = "nb_rest_10000inhab",
           breaks = bks, col = cols, border = "grey80", lwd = 0.5,
           legend.pos = "topleft",add = TRUE,
           legend.title.txt = "Number of restaurants\nfor 10,000 inhabitants")
# Plot proportionnal symbols
propSymbolsLayer(epci_31, var="nb_of_rest", col="#440170",border=NA,
                 legend.pos="left", inches=0.4, add = TRUE,
                 legend.title.txt = "Number of restaurants")
# Add a layout layer
layoutLayer(title = "Restaurants", sources = "Insee, 2018",
            author = "Kim & Tim, 2018",
            theme = "green.pal", col = "darkred",
            coltitle = "white", postitle = "center",
            frame = TRUE, scale = 10)
# Add a north (south) arrow
north(pos = "topright", south = TRUE)
```

##### ggplot2
```{r, nm=TRUE, echo=FALSE}
library(ggplot2)

map_ggplot <- ggplot() +
  geom_sf(data = fra, colour = "ivory3",
          fill = "ivory") +
  geom_sf(data = epci_31, aes(fill = typo), colour = "grey80") +
  scale_fill_manual(name = "Number of restaurants\nfor 10,000 inhabitants",
                    values = cols, na.value = "#303030")+
   geom_sf(data = epci_31 %>%  st_centroid(),
           aes(size= nb_of_rest), color = "#440154CC", show.legend = 'point')+
  scale_size(name = "Number of restaurants",
             breaks = c(1, 500, 3200),
             range = c(0,18))+
  coord_sf(crs = 2154, datum = NA,
           xlim = st_bbox(epci_31)[c(1,3)],
           ylim = st_bbox(epci_31)[c(2,4)]
  ) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "azure",color=NA)) +
  labs(
      title = "Restaurants",
      caption = "Insee, 2018\nKim & Tim, 2018"
  )
plot(map_ggplot)
```

##### tmap
**TODO Timothée**

#### {}


<!-- ```{block, box.title = "3", box.body = list(fill = "white"), box.icon = "fa-star"} -->
<!-- What other solution could we use to display these two variable on the same map? Try it using the `cartography` package. -->
<!-- ``` -->

<!-- ```{block, opts.label = "clues"} -->
<!-- The `propSymbolsChoroLayer` function allows you to draw colored proportional circles. -->
<!-- ``` -->

<!-- ```{r, nm=TRUE, eval=FALSE, echo=TRUE, solution=TRUE} -->
<!-- # Define plot margins -->
<!-- par(mar = c(0.2, 0.2, 1.4, 0.2), bg = "azure") -->
<!-- # Find EPCI bounding box -->
<!-- bb <- st_bbox(epci_31) -->
<!-- # Plot France using EPCI boundingbox -->
<!-- plot(st_geometry(fra), col="ivory", border = "ivory3",  -->
<!--      xlim = bb[c(1, 3)], ylim = bb[c(2, 4)]) -->
<!-- # Plot EPCI -->
<!-- plot(st_geometry(epci_31), col="ivory3", border = "ivory2", add=T) -->
<!-- # Plot the choropleth layer -->
<!-- propSymbolsChoroLayer(epci_31, var = "nb_of_rest", var2 = "nb_rest_10000inhab",  -->
<!--            breaks = bks, col = cols, border = "grey80", lwd = 0.5,  -->
<!--            legend.var.pos = "topleft", legend.var2.pos = "left", -->
<!--            add = TRUE, inches = 0.4, -->
<!--            legend.var.title.txt = "Number of restaurants", -->
<!--            legend.var2.title.txt = "Number of restaurants\nfor 10,000 inhabitants") -->
<!-- # Add a layout layer -->
<!-- layoutLayer(title = "Restaurants", sources = "Insee, 2018",  -->
<!--             author = "Kim & Tim, 2018",  -->
<!--             theme = "green.pal", col = "darkred",  -->
<!--             coltitle = "white", postitle = "center", -->
<!--             frame = TRUE, scale = 10) -->
<!-- # Add a north (south) arrow -->
<!-- north(pos = "topright", south = TRUE) -->

<!-- ``` -->

<!-- ```{r, nm=TRUE, echo=FALSE} -->
<!-- # Define plot margins -->
<!-- par(mar = c(0.2, 0.2, 1.4, 0.2), bg = "azure") -->
<!-- # Find EPCI bounding box -->
<!-- bb <- st_bbox(epci_31) -->
<!-- # Plot France using EPCI boundingbox -->
<!-- plot(st_geometry(fra), col="ivory", border = "ivory3",  -->
<!--      xlim = bb[c(1, 3)], ylim = bb[c(2, 4)]) -->
<!-- # Plot EPCI -->
<!-- plot(st_geometry(epci_31), col="ivory3", border = "ivory2", add=T) -->
<!-- # Plot the choropleth layer -->
<!-- propSymbolsChoroLayer(epci_31, var = "nb_of_rest", var2 = "nb_rest_10000inhab",  -->
<!--            breaks = bks, col = cols, border = "grey80", lwd = 0.5,  -->
<!--            legend.var.pos = "topleft", legend.var2.pos = "left", -->
<!--            add = TRUE, inches = 0.4, -->
<!--            legend.var.title.txt = "Number of restaurants", -->
<!--            legend.var2.title.txt = "Number of restaurants\nfor 10,000 inhabitants") -->
<!-- # Add a layout layer -->
<!-- layoutLayer(title = "Restaurants", sources = "Insee, 2018",  -->
<!--             author = "Kim & Tim, 2018",  -->
<!--             theme = "green.pal", col = "darkred",  -->
<!--             coltitle = "white", postitle = "center", -->
<!--             frame = TRUE, scale = 10) -->
<!-- # Add a north (south) arrow -->
<!-- north(pos = "topright", south = TRUE) -->
<!-- ``` -->



<!-- ```{block, box.title = "4", box.body = list(fill = "white"), box.icon = "fa-star"} -->
<!-- Using the `cartography` package, display the number of restaurants and the number of restaurants per 10,000 inhabitants at the municipalities and EPCI scales. The two maps displayed side by side should be as much comparable as possible. -->
<!-- ``` -->


<!-- ```{r, nm=TRUE, eval=TRUE, echo=TRUE, solution=TRUE, fig.width=10} -->
<!-- library(sf) -->
<!-- library(cartography) -->
<!-- library(dplyr) -->
<!-- # Import data -->
<!-- fra <- st_read("data/fra.shp", quiet = TRUE) -->
<!-- epci_31 <- readRDS("data/epci_31.rds") -->
<!-- com_31 <- readRDS("data/com_31.rds") -->

<!-- # Create the variable -->
<!-- epci_31$nb_rest_10000inhab <- 10000 * epci_31$nb_of_rest / epci_31$P14_POP -->
<!-- com_31$nb_rest_10000inhab <- 10000 * com_31$nb_of_rest / com_31$P14_POP -->

<!-- # Define breaks for municipalities (we will use the same breaks for both maps) -->
<!-- bks_com <- getBreaks(v = com_31$nb_rest_10000inhab[com_31$nb_of_rest>0],  -->
<!--                      method = "quantile", nclass = 6) -->
<!-- # Define color palette -->
<!-- cols <- carto.pal("wine.pal", length(bks_com)-1) -->

<!-- # Define plot margins -->
<!-- par(mar = c(0, 0.1, 1.2, 0.1), bg = "azure", mfrow = c(1,2)) -->
<!-- # Find EPCI bounding box -->
<!-- bb <- st_bbox(epci_31) -->
<!-- # Plot France using EPCI boundingbox -->
<!-- plot(st_geometry(fra), col="ivory", border = "ivory3",  -->
<!--      xlim = bb[c(1, 3)], ylim = bb[c(2, 4)]) -->
<!-- # Plot EPCI -->
<!-- plot(st_geometry(epci_31), col="ivory3", border = "ivory2", add=T) -->
<!-- # Plot the choropleth layer -->
<!-- propSymbolsChoroLayer(epci_31, var = "nb_of_rest", var2 = "nb_rest_10000inhab",  -->
<!--            breaks = bks_com, col = cols, border = "ivory3",lwd = 0.6,  -->
<!--            legend.var.pos = "bottomright", legend.var2.pos = "n", -->
<!--            add = TRUE, inches = 0.5, -->
<!--            legend.var.title.txt = "Number of restaurants") -->
<!-- # Add a layout layer -->
<!-- layoutLayer(title = "Restaurants", sources = "Insee, 2018",  -->
<!--             author = "Kim & Tim, 2018",  -->
<!--             theme = "green.pal", col = "darkred",  -->
<!--             coltitle = "white", postitle = "center", -->
<!--             frame = FALSE, scale = NULL) -->


<!-- bb <- st_bbox(epci_31) -->
<!-- # Plot France using EPCI boundingbox -->
<!-- plot(st_geometry(fra), col="ivory", border = "ivory3",  -->
<!--      xlim = bb[c(1, 3)], ylim = bb[c(2, 4)]) -->
<!-- # Plot EPCI -->
<!-- plot(st_geometry(com_31), col="ivory3", border = "ivory2",lwd = .5, add=T) -->
<!-- # Plot the choropleth layer -->
<!-- propSymbolsChoroLayer(com_31, var = "nb_of_rest", var2 = "nb_rest_10000inhab",  -->
<!--            breaks = bks_com, col = cols, border = "ivory3",lwd = 0.6,  -->
<!--            fixmax = max(epci_31$nb_of_rest), -->
<!--            legend.var.pos = "n", legend.var2.pos = "bottom", -->
<!--            add = TRUE, inches = 0.5, legend.var2.values.rnd = 0, -->
<!--            legend.var2.title.txt = "Number of restaurants\nfor 10,000 inhabitants") -->
<!-- # Add a layout layer -->
<!-- layoutLayer(title = "Restaurants", sources = "",  -->
<!--             author = "",  -->
<!--             theme = "green.pal", col = "darkred",  -->
<!--             coltitle = "white", postitle = "center", -->
<!--             frame = FALSE, scale = 10) -->
<!-- # Add a north (south) arrow -->
<!-- north(pos = "topright", south = TRUE) -->


<!-- ``` -->


# Exercise 3 : Interactive maps and OSM data

In this exercice we will use mapview and leaflet to explore two data source on restaurants Siren which we alrady used previously and one extracted from OSM thanks to the osmdata package.

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}
Load the dataset ‘sir_75’ used previously and map the more than 23,000 restaurants of paris with the `mapview` package. Try using different parameters to customize your map.
```

```{block, opts.label = "information"}
For example, you can use the `map.types`, `col.regions`, `label`, `color`, `legend`, `layer.name`, `homebutton`, `lwd` ... parameters of the `mapview` function.
```

```{r, nm=TRUE, eval=FALSE, echo=TRUE, solution=TRUE}
library(mapview)
library(sf)

sir_75 <- readRDS("data/sir_75.rds")
mapview(sir_75, map.types = "OpenStreetMap",
        col.regions = "#940000",
        label = paste(sir_31$L2_NORMALISEE, sir_31$NOMEN_LONG, sep = " - "),
        color = "white", legend = TRUE, layer.name = "Restaurants in SIRENE",
        homebutton = FALSE, lwd = 0.5)
```

```{r, nm=TRUE, eval=TRUE, echo=FALSE}
library(mapview)
library(sf)

mapview(sir_75, map.types = "OpenStreetMap",
        col.regions = "#940000",
        label = sir_75$L1_NORM,
        color = "white", legend = TRUE, layer.name = "Restaurants in SIRENE",
        homebutton = FALSE, lwd = 0.2)
```

```{block, box.title = "2", box.body = list(fill = "white"), box.icon = "fa-star"}
Use the ‘iris_75 ’polygons to extract a bounding box in WGS84 for Paris. Then take advantage of the `osmdata` package to retrieve all the restaurants and fast-foods inside this bounding box, store the restults in a variable called restaurants. This objects are mapped in  OSM with the key:value pairs amenity:restaurants and amenity:fast_food.
```

```{block, opts.label = "clues"}
Use `sf::st_bbox()` and `sf::st_transform()` for extracting the bounding box. The epsg code of WGS84 is 4326.
Use `osmdata:opq()` to define the boudning box of the osm request, `osmdata:add_osm_feature()` to define the key values pairs you are loonking for and `osmdata:osmdata_sf()` to retrieve the osm data.
```

```{r, nm=TRUE, eval=FALSE, echo=TRUE, solution=TRUE}
library(osmdata)

bb      <- iris_75 %>% st_transform(4326) %>% st_bbox()
q       <- opq(bbox = bb,timeout = 180)
qr      <- add_osm_feature(q, key = 'amenity',value = 'restaurant')
qff     <- add_osm_feature(q, key = 'amenity',value = 'fast_food')

restaurants <- c(osmdata_sf(qr),osmdata_sf(qff))
                 
```
```{r, nm=TRUE, eval=TRUE, echo=FALSE}
library(osmdata)

bb      <- iris_75 %>% st_transform(4326) %>% st_bbox()
q       <- opq(bbox = bb,timeout = 180)
qr      <- add_osm_feature (q, key = 'amenity',value = 'restaurant')
qff     <- add_osm_feature (q, key = 'amenity',value = 'fast_food')

restaurants <- c(osmdata_sf(qr),osmdata_sf(qff))
                 
```

```{block, box.title = "3", box.body = list(fill = "white"), box.icon = "fa-star"}
Use the following code to clean the results and projet them in lambert93. This code keeps only the name attribute, compute the centroid for the restaurants stored as polygons or mutpli-polygons and cleans the points to remove the ones that were extracted from exploding the polygins. Eventually, the restaurants outside of Paris are removed.
```

```{r, nm=TRUE, eval=TRUE, echo=TRUE}

rmpoly <- restaurants$osm_multipolygons %>% 
  st_transform(2154) %>% 
  select(name) %>% st_centroid()

rpoint <- restaurants$osm_points %>% 
  filter(!is.na(amenity)) %>% 
  st_transform(2154) %>% select(name) 

rpoly  <- restaurants$osm_polygons %>% 
  st_transform(2154) %>% 
  select(name)  %>% st_centroid()

restaurants_osm <- rbind(rmpoly,rpoly,rpoint)   

osm_75 <- st_intersection(restaurants_osm , iris_75 %>% st_geometry() %>% st_union())
```


```{block, box.title = "4", box.body = list(fill = "white"), box.icon = "fa-star"}
Store a mapview map of the restaurants stored in sir_75 and another one of those extracted from OSM. Use the sync function of the mapview package to display both maps in a side by side fashion with synchronisation.  
```

```{r, nm=TRUE, eval=FALSE, echo=TRUE, solution=TRUE}
library(mapview)


map_osm = mapview(osm_75, map.types = "OpenStreetMap", 
        col.regions = "#940000", 
        label = as.character(osm_75$name), 
        color = "white", legend = FALSE, layer.name = "Restaurants in OSM",
        homebutton = FALSE, lwd = 0.5) 

map_sir = mapview(sir_75, map.types = "OpenStreetMap", 
        col.regions = "#940000", 
        label = sir_75$L2_NORMA, 
        color = "white", legend = TRUE, layer.name = "Restaurants in SIREN",
        homebutton = FALSE, lwd = 0.5) 

sync(map_osm,map_sir)
```

```{r, nm=TRUE, eval=TRUE, echo=FALSE}
library(mapview)


map_osm = mapview(osm_75, map.types = "OpenStreetMap", 
        col.regions = "#940000", 
        label = as.character(osm_75$name), 
        color = "white", legend = FALSE, layer.name = "Restaurants in OSM",
        homebutton = FALSE, lwd = 0.5) 

map_sir = mapview(sir_75, map.types = "OpenStreetMap", 
        col.regions = "#940000", 
        label = sir_75$L2_NORMA, 
        color = "white", legend = TRUE, layer.name = "Restaurants in SIREN",
        homebutton = FALSE, lwd = 0.5) 

sync(map_osm,map_sir)
```

## Bonus : find location to improve osm data


```{block, box.title = "5", box.body = list(fill = "white"), box.icon = "fa-star"}
Use the `pt_in_grid` function to count the number of restaurants per grid cell of 500 meters square for both datasets. Then, merge the two resulting grid to compute the number of missing restaurants in OSM with respect to the SIREN data-source and use leaflet to draw a grided choropleth.
```

```{r, nm=TRUE, eval=TRUE, echo=TRUE}
pt_in_grid <- function(feat, adm, cellsize = 1000){
  grid <- st_make_grid(x = adm, cellsize = cellsize, what = "polygons")
  . <- st_intersects(grid, adm)
  grid <- grid[sapply(X = ., FUN = length)>0]
  . <- st_intersects(grid, feat)
  grid <- st_sf(n = sapply(X = ., FUN = length), grid)
  return(grid)
}
```


```{r, nm=TRUE, eval=FALSE, echo=TRUE, solution=TRUE}
library(leaflet)
gr_osm <- pt_in_grid(osm_75,iris_75,500)
gr_sir <- pt_in_grid(sir_75,iris_75,500)

grid <- gr_osm %>% rename(osm=n) %>% 
  mutate(siren = gr_sir$n) %>% 
  filter(siren==0,osm==0) %>%
  mutate(missing =  pmax(siren - osm,0))


bks = c(0,5,10,20,40,80,160,300)
cols <- carto.pal("green.pal", 7)
color.scale <- colorBin(cols, domain = range(bks), bins=bks)
leaflet(grid  %>% st_transform(4326) %>% filter(!is.na(missing))) %>% addProviderTiles(providers$Stamen.TonerLite) %>% 
  addPolygons(fillColor = ~color.scale(missing), stroke = FALSE, fillOpacity = 0.7) %>% 
  addLegend(colors = cols, labels = round(bks[1:(length(bks)-1)]*10)/10,
            title = "# net difference between</br> restaurants in </br>SIREN and OSM")


```


```{r, nm=TRUE, eval=TRUE, echo=FALSE}
library(leaflet)
gr_osm <- pt_in_grid(osm_75,iris_75,500)
gr_sir <- pt_in_grid(sir_75,iris_75,500)

grid <- gr_osm %>% rename(osm=n) %>% 
  mutate(siren = gr_sir$n) %>% 
  mutate(missing =  pmax(siren - osm,0))


bks = c(0,5,10,20,40,80,160,300)
cols <- carto.pal("green.pal", 7)
color.scale <- colorBin(cols, domain = range(bks), bins=bks)
leaflet(grid  %>% st_transform(4326) %>% filter(!is.na(missing))) %>% addProviderTiles(providers$Stamen.TonerLite) %>% 
  addPolygons(fillColor = ~color.scale(missing), stroke = FALSE, fillOpacity = 0.7) %>% 
  addLegend(colors = cols, labels = round(bks[1:(length(bks)-1)]*10)/10,
            title = "# net difference between</br> restaurants in </br>SIREN and OSM")


```

--------------------------------------------

--------------------------------------------

**reproducibility**

```{r}
sessionInfo()
```
